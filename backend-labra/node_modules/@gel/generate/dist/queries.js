"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ImportMap = exports.cardinalityToExecutorMethod = void 0;
exports.generateQueryFiles = generateQueryFiles;
exports.stringifyImports = stringifyImports;
exports.generateFiles = generateFiles;
const node_path_1 = __importDefault(require("node:path"));
const node_fs_1 = require("node:fs");
const gel_1 = require("gel");
const genutil_1 = require("./genutil");
const { walk, readFileUtf8 } = gel_1.systemUtils;
async function generateQueryFiles(params) {
    if (params.options.file && params.options.watch) {
        throw new Error(`Using --watch and --file mode simultaneously is not
currently supported.`);
    }
    const noRoot = !params.root;
    const root = params.root ?? process.cwd();
    if (noRoot) {
        console.warn(`No project config file found, using process.cwd() as root directory:
   ${params.root}
`);
    }
    else {
        console.log(`Detected project root via project config file:`);
        console.log("   " + params.root);
    }
    const { client } = params;
    console.log(`Detected schema directory: ${params.schemaDir}`);
    const matches = await getMatches(root, params.schemaDir);
    if (matches.length === 0) {
        console.log(`No .edgeql files found outside of ${params.schemaDir}`);
        return;
    }
    console.log(`Connecting to database...`);
    await client.ensureConnected();
    console.log(`Analyzing .edgeql files...`);
    if (params.options.file) {
        const filesByExtension = {};
        let wasError = false;
        await Promise.all(matches.map(async (p) => {
            const prettyPath = "./" + node_path_1.default.posix.relative(root, p);
            try {
                const query = await readFileUtf8(p);
                const types = await gel_1.$.analyzeQuery(client, query);
                console.log(`   ${prettyPath}`);
                const files = generateFiles({
                    target: params.options.target,
                    path: p,
                    types,
                });
                for (const f of files) {
                    if (!filesByExtension[f.extension]) {
                        filesByExtension[f.extension] = f;
                    }
                    else {
                        filesByExtension[f.extension].contents += `\n\n` + f.contents;
                        filesByExtension[f.extension].imports = filesByExtension[f.extension].imports.merge(f.imports);
                    }
                }
            }
            catch (err) {
                wasError = true;
                console.log(`Error in file '${prettyPath}': ${err.toString()}`);
            }
        }));
        if (!wasError) {
            console.log(`Generating query file${Object.keys(filesByExtension).length > 1 ? "s" : ""}...`);
            for (const [extension, file] of Object.entries(filesByExtension)) {
                const filePath = (node_path_1.default.isAbsolute(params.options.file)
                    ? params.options.file
                    : node_path_1.default.join(process.cwd(), params.options.file)) + extension;
                const prettyPath = node_path_1.default.isAbsolute(params.options.file)
                    ? filePath
                    : `./${node_path_1.default.posix.relative(root, filePath)}`;
                console.log(`   ${prettyPath}`);
                await node_fs_1.promises.writeFile(filePath, genutil_1.headerComment +
                    `${stringifyImports(file.imports)}\n\n${file.contents}`);
            }
        }
        return;
    }
    async function generateFilesForQuery(p) {
        try {
            const query = await readFileUtf8(p);
            if (!query)
                return;
            const types = await gel_1.$.analyzeQuery(client, query);
            const files = generateFiles({
                target: params.options.target,
                path: p,
                types,
            });
            for (const f of files) {
                const prettyPath = "./" + node_path_1.default.posix.relative(root, f.path);
                console.log(`   ${prettyPath}`);
                await node_fs_1.promises.writeFile(f.path, genutil_1.headerComment + `${stringifyImports(f.imports)}\n\n${f.contents}`);
            }
        }
        catch (err) {
            console.log(`Error in file './${node_path_1.default.posix.relative(root, p)}': ${err.toString()}`);
        }
    }
    console.log(`Generating files for following queries:`);
    await Promise.all(matches.map(generateFilesForQuery));
}
function stringifyImports(imports) {
    return [...imports]
        .map(([module, specifiers]) => `import type {${[...specifiers].join(", ")}} from "${module}";`)
        .join("\n");
}
async function getMatches(root, schemaDir) {
    return walk(root, {
        match: [/[^/]\.edgeql$/],
        skip: [
            /node_modules/,
            RegExp(`${schemaDir}\\${node_path_1.default.sep}migrations`),
            RegExp(`${schemaDir}\\${node_path_1.default.sep}fixups`),
        ],
    });
}
function generateFiles(params) {
    const queryFileName = node_path_1.default.basename(params.path);
    const baseFileName = queryFileName.replace(/\.edgeql$/, "");
    const outputDirname = node_path_1.default.dirname(params.path);
    const outputBaseFileName = node_path_1.default.join(outputDirname, `${baseFileName}.query`);
    const method = exports.cardinalityToExecutorMethod[params.types.cardinality];
    if (!method) {
        const validCardinalities = Object.values(gel_1.$.Cardinality);
        throw new Error(`Invalid cardinality: ${params.types.cardinality}. Expected one of ${validCardinalities.join(", ")}.`);
    }
    const functionName = baseFileName
        .replace(/-[A-Za-z]/g, (m) => m[1].toUpperCase())
        .replace(/^[^A-Za-z_]|\W/g, "_");
    const interfaceName = functionName.charAt(0).toUpperCase() + functionName.slice(1);
    const argsInterfaceName = `${interfaceName}Args`;
    const returnsInterfaceName = `${interfaceName}Returns`;
    const hasArgs = params.types.args && params.types.args !== "null";
    const queryDefs = `\
${hasArgs ? `export type ${argsInterfaceName} = ${params.types.args};\n` : ""}
export type ${returnsInterfaceName} = ${params.types.result};\
`;
    const functionBody = `\
${params.types.query.trim().replace(/\\/g, "\\\\").replace(/`/g, "\\`")}\`${hasArgs ? `, args` : ""});
`;
    const tsImports = params.types.importMap ??
        new ImportMap(params.types.imports ? [["gel", params.types.imports]] : []);
    tsImports.add("gel", "Executor");
    const tsImpl = `${queryDefs}

export function ${functionName}(client: Executor${hasArgs ? `, args: ${argsInterfaceName}` : ""}): Promise<${returnsInterfaceName}> {
  return client.${method}(\`\\
${functionBody}
}
`;
    const denoImpl = `
${tsImpl}`;
    const jsImpl = `async function ${functionName}(client${hasArgs ? `, args` : ""}) {
  return client.${method}(\`\\
${functionBody}
}`;
    const dtsImpl = `${queryDefs}

export function ${functionName}(client: Executor${hasArgs ? `, args: ${argsInterfaceName}` : ""}): Promise<${returnsInterfaceName}>;`;
    switch (params.target) {
        case "cjs":
            return [
                {
                    path: `${outputBaseFileName}.js`,
                    contents: `${jsImpl}\n\nmodule.exports.${functionName} = ${functionName};`,
                    imports: new ImportMap(),
                    extension: ".js",
                },
                {
                    path: `${outputBaseFileName}.d.ts`,
                    contents: dtsImpl,
                    imports: tsImports,
                    extension: ".d.ts",
                },
            ];
        case "deno":
            return [
                {
                    path: `${outputBaseFileName}.ts`,
                    contents: denoImpl,
                    imports: tsImports,
                    extension: ".ts",
                },
            ];
        case "esm":
            return [
                {
                    path: `${outputBaseFileName}.mjs`,
                    contents: `export ${jsImpl}`,
                    imports: new ImportMap(),
                    extension: ".mjs",
                },
                {
                    path: `${outputBaseFileName}.d.ts`,
                    contents: dtsImpl,
                    imports: tsImports,
                    extension: ".d.ts",
                },
            ];
        case "mts":
            return [
                {
                    path: `${outputBaseFileName}.mts`,
                    contents: tsImpl,
                    imports: tsImports,
                    extension: ".mts",
                },
            ];
        case "ts":
            return [
                {
                    path: `${outputBaseFileName}.ts`,
                    contents: tsImpl,
                    imports: tsImports,
                    extension: ".ts",
                },
            ];
    }
}
exports.cardinalityToExecutorMethod = {
    One: "queryRequiredSingle",
    AtMostOne: "querySingle",
    Many: "query",
    AtLeastOne: "queryRequired",
    Empty: "query",
};
class ImportMap extends Map {
    add(module, specifier) {
        if (!this.has(module)) {
            this.set(module, new Set());
        }
        this.get(module).add(specifier);
        return this;
    }
    merge(map) {
        const out = new ImportMap();
        for (const [mod, specifiers] of [...this, ...map]) {
            for (const specifier of specifiers) {
                out.add(mod, specifier);
            }
        }
        return out;
    }
}
exports.ImportMap = ImportMap;
